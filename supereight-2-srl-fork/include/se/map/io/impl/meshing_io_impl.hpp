/*
 * SPDX-FileCopyrightText: 2016-2019 Emanuele Vespa
 * SPDX-FileCopyrightText: 2018-2021 Smart Robotics Lab, Imperial College London, Technical University of Munich
 * SPDX-FileCopyrightText: 2019-2021 Nils Funk
 * SPDX-FileCopyrightText: 2020-2021 Sotiris Papatheodorou
 * SPDX-License-Identifier: BSD-3-Clause
 */

#ifndef SE_MESHING_IO_IMPL_HPP
#define SE_MESHING_IO_IMPL_HPP

namespace se {
namespace io {

template<typename FaceT>
int save_mesh_vtk(const Mesh<FaceT>& mesh,
                  const std::string& filename,
                  const Eigen::Matrix4f& T_OM,
                  const float* point_data,
                  const float* cell_data)
{
    // Open the file for writing.
    std::ofstream file(filename.c_str());
    if (!file.is_open()) {
        std::cerr << "Unable to write file " << filename << "\n";
        return 1;
    }

    const size_t num_faces = mesh.size();
    const size_t num_vertices = FaceT::num_vertexes * num_faces;
    const bool has_point_data = point_data != nullptr;
    const bool has_cell_data = cell_data != nullptr;

    // Write the header.
    file << "# vtk DataFile Version 1.0\n";
    file << "vtk mesh generated from supereight 2\n";
    file << "ASCII\n";
    file << "DATASET POLYDATA\n";

    // Write the vertices.
    file << "POINTS " << num_vertices << " FLOAT\n";
    for (size_t f = 0; f < num_faces; ++f) {
        for (size_t v = 0; v < FaceT::num_vertexes; ++v) {
            const Eigen::Vector3f vertex_W =
                (T_OM * mesh[f].vertexes[v].homogeneous()).template head<3>();
            file << vertex_W.x() << " " << vertex_W.y() << " " << vertex_W.z() << "\n";
        }
    }

    // Write the faces.
    file << "POLYGONS " << num_faces << " " << num_faces * (1 + FaceT::num_vertexes) << "\n";
    for (size_t f = 0; f < num_faces; ++f) {
        file << FaceT::num_vertexes;
        for (size_t v = 0; v < FaceT::num_vertexes; ++v) {
            file << " " << FaceT::num_vertexes * f + v;
        }
        file << "\n";
    }

    // Write the vertex data.
    if (has_point_data) {
        file << "POINT_DATA " << num_vertices << "\n";
        file << "SCALARS vertex_scalars float 1\n";
        file << "LOOKUP_TABLE default\n";
        for (size_t f = 0; f < num_faces; ++f) {
            for (size_t v = 0; v < FaceT::num_vertexes; ++v) {
                file << point_data[f * FaceT::num_vertexes + v] << "\n";
            }
        }
    }

    // Write the face scale colours.
    file << "CELL_DATA " << num_faces << "\n";
    file << "COLOR_SCALARS RGBA 4\n";
    for (size_t f = 0; f < num_faces; ++f) {
        // Colour the triangle depending on its scale.
        const Eigen::Vector3f RGB = se::colours::scale[mesh[f].max_vertex_scale] / 255.0f;
        file << RGB[0] << " " << RGB[1] << " " << RGB[2] << " 1\n";
    }

    // Write the face data.
    if (has_cell_data) {
        file << "SCALARS cell_scalars float 1\n";
        file << "LOOKUP_TABLE default\n";
        for (size_t f = 0; f < num_faces; ++f) {
            file << cell_data[f] << "\n";
        }
    }

    file.close();
    return 0;
}



template<typename FaceT>
int save_mesh_ply(const Mesh<FaceT>& mesh,
                  const std::string& filename,
                  const Eigen::Matrix4f& T_OM,
                  const float* point_data,
                  const float* cell_data)
{
    // Open the file for writing.
    std::ofstream file(filename.c_str());
    if (!file.is_open()) {
        std::cerr << "Unable to write file " << filename << "\n";
        return 1;
    }

    const size_t num_faces = mesh.size();
    const size_t num_vertices = FaceT::num_vertexes * num_faces;
    const bool has_point_data = point_data != nullptr;
    const bool has_cell_data = cell_data != nullptr;

    // Write header
    file << "ply\n";
    file << "format ascii 1.0\n";
    file << "comment Generated by supereight\n";
    file << "element vertex " << num_vertices << "\n";
    file << "property float x\n";
    file << "property float y\n";
    file << "property float z\n";
    if (has_point_data) {
        file << "property float vertex_value\n";
    }
    file << "element face " << num_faces << "\n";
    file << "property list uchar int vertex_index\n";
    file << "property uchar red\n";
    file << "property uchar green\n";
    file << "property uchar blue\n";
    if (has_cell_data) {
        file << "property float face_value\n";
    }
    file << "end_header\n";

    // Write the vertices and the vertex data.
    for (size_t f = 0; f < num_faces; ++f) {
        for (size_t v = 0; v < FaceT::num_vertexes; ++v) {
            const Eigen::Vector3f vertex_W =
                (T_OM * mesh[f].vertexes[v].homogeneous()).template head<3>();
            file << vertex_W.x() << " " << vertex_W.y() << " " << vertex_W.z();
            if (has_point_data) {
                file << " " << point_data[f * FaceT::num_vertexes + v] << "\n";
            }
            else {
                file << "\n";
            }
        }
    }

    // Write the faces and the face data.
    for (size_t f = 0; f < num_faces; ++f) {
        file << FaceT::num_vertexes;
        for (size_t v = 0; v < FaceT::num_vertexes; ++v) {
            file << " " << FaceT::num_vertexes * f + v;
        }
        // Write the face scale colour.
        const Eigen::Vector3i RGB =
            se::colours::scale[mesh[f].max_vertex_scale].template cast<int>();
        file << " " << RGB[0] << " " << RGB[1] << " " << RGB[2];
        if (has_cell_data) {
            file << " " << cell_data[f] << "\n";
        }
        else {
            file << "\n";
        }
    }

    file.close();
    return 0;
}



template<typename FaceT>
int save_mesh_obj(const Mesh<FaceT>& mesh, const std::string& filename, const Eigen::Matrix4f& T_OM)
{
    // Open the file for writing.
    std::ofstream file(filename.c_str());
    if (!file.is_open()) {
        std::cerr << "Unable to write file " << filename << "\n";
        return 1;
    }

    const size_t num_faces = mesh.size();
    const size_t num_vertices = FaceT::num_vertexes * num_faces;

    // Write the header.
    file << "# OBJ file format with ext .obj" << std::endl;
    file << "# vertex count = " << num_vertices << std::endl;
    file << "# face count = " << num_faces << std::endl;

    // Write the vertices.
    for (size_t f = 0; f < num_faces; ++f) {
        for (size_t v = 0; v < FaceT::num_vertexes; ++v) {
            const Eigen::Vector3f vertex_W =
                (T_OM * mesh[f].vertexes[v].homogeneous()).template head<3>();
            file << "v " << vertex_W.x() << " " << vertex_W.y() << " " << vertex_W.z() << "\n";
        }
    }

    // Write the faces.
    for (size_t f = 0; f < num_faces; ++f) {
        file << "f ";
        for (size_t v = 0; v < FaceT::num_vertexes; ++v) {
            file << " " << FaceT::num_vertexes * f + v + 1;
        }
        file << "\n";
    }

    file.close();
    return 0;
}

} // namespace io
} // namespace se

#endif // SE_MESHING_IO_IMPL_HPP
